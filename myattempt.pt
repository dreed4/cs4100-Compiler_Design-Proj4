
<parameter infile message="input file name"/>

<*============ reading the input code =================*>
<* parse the in file using syntax defined in our code file, will output to ast *>
<input from=(infile) syntax="Cfront.code" to = ast />

<*============ control flow graph IR and management ===============*>

<* define our nodes and edges, including our index *>
<define cfg_nodes NULL/>
<define cfg_edges NULL/>
<define label_index 0/>

<* function that will return a new label *>
<xform new_label > GLOBAL.lab_index=GLOBAL.label_index+1; GLOBAL.label_index </xform>

<* basic block IR data structure *>
<code Flow pars=(from, to)>
B@from@->B@to@
</code>

<code DFG pars=(nodes, edges)>
digraph CFG
{
	@CODE.print_list#(nodes,"\n")@
	@CODE.print_list#(edges,"\n")@
}
</code>

<*print content backward *>
<code print_lsit pars=(content,sep)>
@((TAIL(content) : NULL)? HEAD(content) :
	(print_list#(TAIL(content),sep) sep HEAD(content)))@
</code>

<* generating a new basic block function *>
<xform new_basicblock pars=(stmts)>
	label = GLOBAL.label_index;
	GLOBAL.cfg_nodes = BasicBlock#(label, stmts) :: GLOBAL.cfg_nodes;
	GLOBAL.label_index = GLOBAL.label_index + 1;
	label
</xform>

<* function to create a new edge *>
<xform new_flow pars=(from, to)>
	GLOBAL.cfg_edges = Flow#(from, to) :: GLOBAL.cfg_edges;
</xform>

<***** translation schemes for control flow graph construction ****>
<* this looks like the place where we'll have to edit it specifically for our code *>
<xform BuildCFG__Goal pars(input, begin)>
	<*this is our start non-term*>
	CODE.DeclarationBlock#(block) = input;
	for (p = block; p!= NULL p = TAIL(p)) {
	   	cur = HEAD(p);
		<* going based on her tutorial, we want all productions of our *>
		<* non-terminal DeclarationBlock *>
		switch(cur) {
			<*we have very few productions for DeclarationBlock fyi*>
			<* pretty sure we need builders for all of these *>
			case GLOBAL.Declaration : begin = cur :: begin;
			case CODE.EmptyStmt : begin = cur :: begin;
			case CODE.DeclStmt : begin = cur :: begin;
		}
	   
	}
</xform>


<* we need implementation schemes for our three non-terminals *>
<* Main issue I don't understand: *>
<* I feel like i need to use these to somehow access the other potential*>
<* block beginnings, but looking at the parsing, I don't see how any of *>
<* these will ever get to for, while, do while, if-else, etc, that would*>
<* need to be the beginning of a block 					*>

<xform BuildCFG__For pars=(input,begin)>
For#(var,lb,ub,incr,body) = input;
b_init = new_basicblock(CODE.Bop#("=",var,lb) :: begin); <* wrap up the previous basic block *>
b_test = new_basicblock(Bop#("<",var,ub)); <* new basic block for test *>
body_label= GLOBAL.label_index; <* label for the first basic block of body *>
body_next = XFORM.BuildCFG__Goal(body,""); <* lable of the last basic block from loop body *>
body_last = new_basicblock(incr::body_next); <* last basic block from loop body*>
exit_label = new_label(); <* exit label for the loop*>
<* new generate cfg edges *>
new_flow(b_init, b_test);
new_flow(b_test, body_label);
new_flow(b_test, exit_label);
new_flow(body_last, b_test);
"" <* the exit block is currently empty*>
</xform>


<xform BuildCFG__GlobalDeclStmt pars=(input, begin)>
	
	
</xform>


<xform BuildCFG_EmptyStmt pars=(input, begin)>
	<*I don't think we need anything in here since it is just empty*>
</xform>


<xform BuildCFG_DeclStmt pars=(input, begin)>
	
</xform>

<* Associative map for traversing the CFG. Needs work. *>
<xform MapSuccessors pars=(cfg)>
	res = MAP(,);
	foreach edge = Flow#(CLEAR from, CLEAR to) \in cfg do
		res[from] = BuildList(to, res[from]);
	enddo
	res
</xform>



<* needs to remain at end of file I think*>
<*<output from=(ast) syntax ="Cfront.code" />*>

<* write to given output file *>
<output from=(CFG#(cfg_nodes, cfg_edges)) sntax="myattempt.code" to=outfile />
